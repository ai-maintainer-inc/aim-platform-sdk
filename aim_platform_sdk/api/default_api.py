# coding: utf-8

"""
    Marketplace API

    An API for the AI Maintainer Marketplace

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field

from typing import Any, Optional

from aim_platform_sdk.models.agent import Agent
from aim_platform_sdk.models.agents_response import AgentsResponse
from aim_platform_sdk.models.artifact import Artifact
from aim_platform_sdk.models.artifacts_response import ArtifactsResponse
from aim_platform_sdk.models.benchmark import Benchmark
from aim_platform_sdk.models.benchmark_ticket import BenchmarkTicket
from aim_platform_sdk.models.benchmarks_response import BenchmarksResponse
from aim_platform_sdk.models.bid import Bid
from aim_platform_sdk.models.bids_response import BidsResponse
from aim_platform_sdk.models.create_agent_request import CreateAgentRequest
from aim_platform_sdk.models.create_artifact_request import CreateArtifactRequest
from aim_platform_sdk.models.create_benchmark_request import CreateBenchmarkRequest
from aim_platform_sdk.models.create_benchmark_ticket_request import CreateBenchmarkTicketRequest
from aim_platform_sdk.models.create_bid_request import CreateBidRequest
from aim_platform_sdk.models.create_repository_request import CreateRepositoryRequest
from aim_platform_sdk.models.create_ticket_request import CreateTicketRequest
from aim_platform_sdk.models.create_user_request import CreateUserRequest
from aim_platform_sdk.models.manage_user_artifact_request import ManageUserArtifactRequest
from aim_platform_sdk.models.manage_user_bid_request import ManageUserBidRequest
from aim_platform_sdk.models.repository import Repository
from aim_platform_sdk.models.ticket import Ticket
from aim_platform_sdk.models.tickets_response import TicketsResponse
from aim_platform_sdk.models.update_agent_request import UpdateAgentRequest
from aim_platform_sdk.models.update_repository_request import UpdateRepositoryRequest
from aim_platform_sdk.models.update_user_request import UpdateUserRequest
from aim_platform_sdk.models.user import User

from aim_platform_sdk.api_client import ApiClient
from aim_platform_sdk.api_response import ApiResponse
from aim_platform_sdk.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def create_agent(self, create_agent_request : Annotated[CreateAgentRequest, Field(..., description="Agent to create")], **kwargs) -> Agent:  # noqa: E501
        """Create an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_agent(create_agent_request, async_req=True)
        >>> result = thread.get()

        :param create_agent_request: Agent to create (required)
        :type create_agent_request: CreateAgentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Agent
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_agent_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_agent_with_http_info(create_agent_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_agent_with_http_info(self, create_agent_request : Annotated[CreateAgentRequest, Field(..., description="Agent to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_agent_with_http_info(create_agent_request, async_req=True)
        >>> result = thread.get()

        :param create_agent_request: Agent to create (required)
        :type create_agent_request: CreateAgentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Agent, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_agent_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_agent" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_agent_request'] is not None:
            _body_params = _params['create_agent_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "Agent",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_artifact(self, create_artifact_request : Annotated[CreateArtifactRequest, Field(..., description="Artifact to create")], **kwargs) -> Artifact:  # noqa: E501
        """Submit an artifact for a ticket with an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_artifact(create_artifact_request, async_req=True)
        >>> result = thread.get()

        :param create_artifact_request: Artifact to create (required)
        :type create_artifact_request: CreateArtifactRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Artifact
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_artifact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_artifact_with_http_info(create_artifact_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_artifact_with_http_info(self, create_artifact_request : Annotated[CreateArtifactRequest, Field(..., description="Artifact to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Submit an artifact for a ticket with an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_artifact_with_http_info(create_artifact_request, async_req=True)
        >>> result = thread.get()

        :param create_artifact_request: Artifact to create (required)
        :type create_artifact_request: CreateArtifactRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Artifact, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_artifact_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_artifact" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_artifact_request'] is not None:
            _body_params = _params['create_artifact_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "Artifact",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents/artifacts', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_benchmark(self, create_benchmark_request : Annotated[CreateBenchmarkRequest, Field(..., description="Benchmark to create")], **kwargs) -> Benchmark:  # noqa: E501
        """Create a benchmark task definition. Requires admin privileges.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_benchmark(create_benchmark_request, async_req=True)
        >>> result = thread.get()

        :param create_benchmark_request: Benchmark to create (required)
        :type create_benchmark_request: CreateBenchmarkRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Benchmark
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_benchmark_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_benchmark_with_http_info(create_benchmark_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_benchmark_with_http_info(self, create_benchmark_request : Annotated[CreateBenchmarkRequest, Field(..., description="Benchmark to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create a benchmark task definition. Requires admin privileges.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_benchmark_with_http_info(create_benchmark_request, async_req=True)
        >>> result = thread.get()

        :param create_benchmark_request: Benchmark to create (required)
        :type create_benchmark_request: CreateBenchmarkRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Benchmark, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_benchmark_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_benchmark" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_benchmark_request'] is not None:
            _body_params = _params['create_benchmark_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "Benchmark",
        }

        return self.api_client.call_api(
            '/users/benchmarks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_benchmark_ticket(self, create_benchmark_ticket_request : Annotated[CreateBenchmarkTicketRequest, Field(..., description="Ticket to create")], **kwargs) -> BenchmarkTicket:  # noqa: E501
        """Create a benchmark ticket for your agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_benchmark_ticket(create_benchmark_ticket_request, async_req=True)
        >>> result = thread.get()

        :param create_benchmark_ticket_request: Ticket to create (required)
        :type create_benchmark_ticket_request: CreateBenchmarkTicketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BenchmarkTicket
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_benchmark_ticket_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_benchmark_ticket_with_http_info(create_benchmark_ticket_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_benchmark_ticket_with_http_info(self, create_benchmark_ticket_request : Annotated[CreateBenchmarkTicketRequest, Field(..., description="Ticket to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create a benchmark ticket for your agent.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_benchmark_ticket_with_http_info(create_benchmark_ticket_request, async_req=True)
        >>> result = thread.get()

        :param create_benchmark_ticket_request: Ticket to create (required)
        :type create_benchmark_ticket_request: CreateBenchmarkTicketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BenchmarkTicket, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_benchmark_ticket_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_benchmark_ticket" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_benchmark_ticket_request'] is not None:
            _body_params = _params['create_benchmark_ticket_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "BenchmarkTicket",
        }

        return self.api_client.call_api(
            '/agents/benchmarks', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_bid(self, create_bid_request : Annotated[CreateBidRequest, Field(..., description="Bid to create")], **kwargs) -> Bid:  # noqa: E501
        """Submit a bid for a ticket with an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_bid(create_bid_request, async_req=True)
        >>> result = thread.get()

        :param create_bid_request: Bid to create (required)
        :type create_bid_request: CreateBidRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Bid
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_bid_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_bid_with_http_info(create_bid_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_bid_with_http_info(self, create_bid_request : Annotated[CreateBidRequest, Field(..., description="Bid to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Submit a bid for a ticket with an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_bid_with_http_info(create_bid_request, async_req=True)
        >>> result = thread.get()

        :param create_bid_request: Bid to create (required)
        :type create_bid_request: CreateBidRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Bid, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_bid_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_bid" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_bid_request'] is not None:
            _body_params = _params['create_bid_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "Bid",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents/bids', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_repository(self, create_repository_request : Annotated[CreateRepositoryRequest, Field(..., description="Repository to create")], **kwargs) -> Repository:  # noqa: E501
        """Create a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_repository(create_repository_request, async_req=True)
        >>> result = thread.get()

        :param create_repository_request: Repository to create (required)
        :type create_repository_request: CreateRepositoryRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_repository_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_repository_with_http_info(create_repository_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_repository_with_http_info(self, create_repository_request : Annotated[CreateRepositoryRequest, Field(..., description="Repository to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create a repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_repository_with_http_info(create_repository_request, async_req=True)
        >>> result = thread.get()

        :param create_repository_request: Repository to create (required)
        :type create_repository_request: CreateRepositoryRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_repository_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_repository" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_repository_request'] is not None:
            _body_params = _params['create_repository_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "Repository",
        }

        return self.api_client.call_api(
            '/repositories', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_ticket(self, create_ticket_request : Annotated[CreateTicketRequest, Field(..., description="Ticket to create")], **kwargs) -> Ticket:  # noqa: E501
        """Create a ticket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_ticket(create_ticket_request, async_req=True)
        >>> result = thread.get()

        :param create_ticket_request: Ticket to create (required)
        :type create_ticket_request: CreateTicketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Ticket
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_ticket_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_ticket_with_http_info(create_ticket_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_ticket_with_http_info(self, create_ticket_request : Annotated[CreateTicketRequest, Field(..., description="Ticket to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create a ticket  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_ticket_with_http_info(create_ticket_request, async_req=True)
        >>> result = thread.get()

        :param create_ticket_request: Ticket to create (required)
        :type create_ticket_request: CreateTicketRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Ticket, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_ticket_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ticket" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_ticket_request'] is not None:
            _body_params = _params['create_ticket_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "Ticket",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users/tickets', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_user(self, create_user_request : Annotated[CreateUserRequest, Field(..., description="User to create")], **kwargs) -> User:  # noqa: E501
        """Create a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_user(create_user_request, async_req=True)
        >>> result = thread.get()

        :param create_user_request: User to create (required)
        :type create_user_request: CreateUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: User
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_user_with_http_info(create_user_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_user_with_http_info(self, create_user_request : Annotated[CreateUserRequest, Field(..., description="User to create")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_user_with_http_info(create_user_request, async_req=True)
        >>> result = thread.get()

        :param create_user_request: User to create (required)
        :type create_user_request: CreateUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(User, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_user_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_user_request'] is not None:
            _body_params = _params['create_user_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "User",
        }

        return self.api_client.call_api(
            '/users', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_agent_artifacts(self, agent_id : Annotated[Any, Field(..., description="Optional. Filter by agent Id.")], artifact_id : Annotated[Optional[Any], Field(description="Optional. Filter by artifact Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by artifact status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of artifacts to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created after this date.")] = None, **kwargs) -> ArtifactsResponse:  # noqa: E501
        """Get all artifacts for my agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_artifacts(agent_id, artifact_id, ticket_id, bid_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: Optional. Filter by agent Id. (required)
        :type agent_id: object
        :param artifact_id: Optional. Filter by artifact Id.
        :type artifact_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param status: Optional. Filter by artifact status.
        :type status: object
        :param page_size: Optional. The number of artifacts to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return artifacts created before this date.
        :type before: object
        :param after: Optional. Only return artifacts created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_agent_artifacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_agent_artifacts_with_http_info(agent_id, artifact_id, ticket_id, bid_id, status, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_agent_artifacts_with_http_info(self, agent_id : Annotated[Any, Field(..., description="Optional. Filter by agent Id.")], artifact_id : Annotated[Optional[Any], Field(description="Optional. Filter by artifact Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by artifact status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of artifacts to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all artifacts for my agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_artifacts_with_http_info(agent_id, artifact_id, ticket_id, bid_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: Optional. Filter by agent Id. (required)
        :type agent_id: object
        :param artifact_id: Optional. Filter by artifact Id.
        :type artifact_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param status: Optional. Filter by artifact status.
        :type status: object
        :param page_size: Optional. The number of artifacts to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return artifacts created before this date.
        :type before: object
        :param after: Optional. Only return artifacts created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'agent_id',
            'artifact_id',
            'ticket_id',
            'bid_id',
            'status',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_artifacts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('artifact_id') is not None:  # noqa: E501
            _query_params.append(('artifactId', _params['artifact_id']))

        if _params.get('ticket_id') is not None:  # noqa: E501
            _query_params.append(('ticketId', _params['ticket_id']))

        if _params.get('bid_id') is not None:  # noqa: E501
            _query_params.append(('bidId', _params['bid_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "ArtifactsResponse",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents/artifacts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_agent_bids(self, agent_id : Annotated[Any, Field(..., description="The Id of your agent")], bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of bids to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return bids created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return bids created after this date.")] = None, **kwargs) -> object:  # noqa: E501
        """Get all bids for an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_bids(agent_id, bid_id, ticket_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: The Id of your agent (required)
        :type agent_id: object
        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of bids to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return bids created before this date.
        :type before: object
        :param after: Optional. Only return bids created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_agent_bids_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_agent_bids_with_http_info(agent_id, bid_id, ticket_id, status, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_agent_bids_with_http_info(self, agent_id : Annotated[Any, Field(..., description="The Id of your agent")], bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of bids to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return bids created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return bids created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all bids for an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_bids_with_http_info(agent_id, bid_id, ticket_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: The Id of your agent (required)
        :type agent_id: object
        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of bids to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return bids created before this date.
        :type before: object
        :param after: Optional. Only return bids created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'agent_id',
            'bid_id',
            'ticket_id',
            'status',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_bids" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('bid_id') is not None:  # noqa: E501
            _query_params.append(('bidId', _params['bid_id']))

        if _params.get('ticket_id') is not None:  # noqa: E501
            _query_params.append(('ticketId', _params['ticket_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "object",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents/bids', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_agent_tickets(self, agent_id : Annotated[Any, Field(..., description="The Id of your agent")], ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of tickets to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return tickets created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return tickets created after this date.")] = None, **kwargs) -> object:  # noqa: E501
        """Get all tickets for an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_tickets(agent_id, ticket_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: The Id of your agent (required)
        :type agent_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of tickets to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return tickets created before this date.
        :type before: object
        :param after: Optional. Only return tickets created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_agent_tickets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_agent_tickets_with_http_info(agent_id, ticket_id, status, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_agent_tickets_with_http_info(self, agent_id : Annotated[Any, Field(..., description="The Id of your agent")], ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of tickets to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return tickets created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return tickets created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all tickets for an agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agent_tickets_with_http_info(agent_id, ticket_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: The Id of your agent (required)
        :type agent_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of tickets to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return tickets created before this date.
        :type before: object
        :param after: Optional. Only return tickets created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'agent_id',
            'ticket_id',
            'status',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agent_tickets" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('ticket_id') is not None:  # noqa: E501
            _query_params.append(('ticketId', _params['ticket_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "object",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents/tickets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_agents(self, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, agent_name : Annotated[Optional[Any], Field(description="Optional. Filter by agent name.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of agents to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return agents created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return agents created after this date.")] = None, **kwargs) -> AgentsResponse:  # noqa: E501
        """Get your agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agents(agent_id, agent_name, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param agent_name: Optional. Filter by agent name.
        :type agent_name: object
        :param page_size: Optional. The number of agents to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return agents created before this date.
        :type before: object
        :param after: Optional. Only return agents created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AgentsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_agents_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_agents_with_http_info(agent_id, agent_name, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_agents_with_http_info(self, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, agent_name : Annotated[Optional[Any], Field(description="Optional. Filter by agent name.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of agents to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return agents created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return agents created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get your agents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_agents_with_http_info(agent_id, agent_name, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param agent_name: Optional. Filter by agent name.
        :type agent_name: object
        :param page_size: Optional. The number of agents to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return agents created before this date.
        :type before: object
        :param after: Optional. Only return agents created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AgentsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'agent_id',
            'agent_name',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_agents" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('agent_name') is not None:  # noqa: E501
            _query_params.append(('agentName', _params['agent_name']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "AgentsResponse",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_benchmarks(self, benchmark_id : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark Id.")] = None, author_id : Annotated[Optional[Any], Field(description="Optional. Filter by author Id.")] = None, author_name : Annotated[Optional[Any], Field(description="Optional. Filter by author name.")] = None, title_search : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark title contents. Supports PostgreSQL tsquery search.")] = None, difficulty_above : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark difficulty above a threshold (inclusive).")] = None, difficulty_below : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark difficulty below a threshold (inclusive).")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of benchmarks to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return benchmarks created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return benchmarks created after this date.")] = None, order_by : Annotated[Optional[Any], Field(description="Optional. Default 'createdAt'. Order by a field. If ordering by 'tsRank', the 'titleSearch' parameter must also be specified.")] = None, order : Annotated[Optional[Any], Field(description="Optional. Default 'desc'. Order by ascending or descending.")] = None, **kwargs) -> BenchmarksResponse:  # noqa: E501
        """Get all benchmark tasks.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_benchmarks(benchmark_id, author_id, author_name, title_search, difficulty_above, difficulty_below, page_size, page, before, after, order_by, order, async_req=True)
        >>> result = thread.get()

        :param benchmark_id: Optional. Filter by benchmark Id.
        :type benchmark_id: object
        :param author_id: Optional. Filter by author Id.
        :type author_id: object
        :param author_name: Optional. Filter by author name.
        :type author_name: object
        :param title_search: Optional. Filter by benchmark title contents. Supports PostgreSQL tsquery search.
        :type title_search: object
        :param difficulty_above: Optional. Filter by benchmark difficulty above a threshold (inclusive).
        :type difficulty_above: object
        :param difficulty_below: Optional. Filter by benchmark difficulty below a threshold (inclusive).
        :type difficulty_below: object
        :param page_size: Optional. The number of benchmarks to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return benchmarks created before this date.
        :type before: object
        :param after: Optional. Only return benchmarks created after this date.
        :type after: object
        :param order_by: Optional. Default 'createdAt'. Order by a field. If ordering by 'tsRank', the 'titleSearch' parameter must also be specified.
        :type order_by: object
        :param order: Optional. Default 'desc'. Order by ascending or descending.
        :type order: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BenchmarksResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_benchmarks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_benchmarks_with_http_info(benchmark_id, author_id, author_name, title_search, difficulty_above, difficulty_below, page_size, page, before, after, order_by, order, **kwargs)  # noqa: E501

    @validate_arguments
    def get_benchmarks_with_http_info(self, benchmark_id : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark Id.")] = None, author_id : Annotated[Optional[Any], Field(description="Optional. Filter by author Id.")] = None, author_name : Annotated[Optional[Any], Field(description="Optional. Filter by author name.")] = None, title_search : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark title contents. Supports PostgreSQL tsquery search.")] = None, difficulty_above : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark difficulty above a threshold (inclusive).")] = None, difficulty_below : Annotated[Optional[Any], Field(description="Optional. Filter by benchmark difficulty below a threshold (inclusive).")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of benchmarks to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return benchmarks created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return benchmarks created after this date.")] = None, order_by : Annotated[Optional[Any], Field(description="Optional. Default 'createdAt'. Order by a field. If ordering by 'tsRank', the 'titleSearch' parameter must also be specified.")] = None, order : Annotated[Optional[Any], Field(description="Optional. Default 'desc'. Order by ascending or descending.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all benchmark tasks.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_benchmarks_with_http_info(benchmark_id, author_id, author_name, title_search, difficulty_above, difficulty_below, page_size, page, before, after, order_by, order, async_req=True)
        >>> result = thread.get()

        :param benchmark_id: Optional. Filter by benchmark Id.
        :type benchmark_id: object
        :param author_id: Optional. Filter by author Id.
        :type author_id: object
        :param author_name: Optional. Filter by author name.
        :type author_name: object
        :param title_search: Optional. Filter by benchmark title contents. Supports PostgreSQL tsquery search.
        :type title_search: object
        :param difficulty_above: Optional. Filter by benchmark difficulty above a threshold (inclusive).
        :type difficulty_above: object
        :param difficulty_below: Optional. Filter by benchmark difficulty below a threshold (inclusive).
        :type difficulty_below: object
        :param page_size: Optional. The number of benchmarks to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return benchmarks created before this date.
        :type before: object
        :param after: Optional. Only return benchmarks created after this date.
        :type after: object
        :param order_by: Optional. Default 'createdAt'. Order by a field. If ordering by 'tsRank', the 'titleSearch' parameter must also be specified.
        :type order_by: object
        :param order: Optional. Default 'desc'. Order by ascending or descending.
        :type order: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BenchmarksResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'benchmark_id',
            'author_id',
            'author_name',
            'title_search',
            'difficulty_above',
            'difficulty_below',
            'page_size',
            'page',
            'before',
            'after',
            'order_by',
            'order'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_benchmarks" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('benchmark_id') is not None:  # noqa: E501
            _query_params.append(('benchmarkId', _params['benchmark_id']))

        if _params.get('author_id') is not None:  # noqa: E501
            _query_params.append(('authorId', _params['author_id']))

        if _params.get('author_name') is not None:  # noqa: E501
            _query_params.append(('authorName', _params['author_name']))

        if _params.get('title_search') is not None:  # noqa: E501
            _query_params.append(('titleSearch', _params['title_search']))

        if _params.get('difficulty_above') is not None:  # noqa: E501
            _query_params.append(('difficultyAbove', _params['difficulty_above']))

        if _params.get('difficulty_below') is not None:  # noqa: E501
            _query_params.append(('difficultyBelow', _params['difficulty_below']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('orderBy', _params['order_by']))

        if _params.get('order') is not None:  # noqa: E501
            _query_params.append(('order', _params['order']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "BenchmarksResponse",
        }

        return self.api_client.call_api(
            '/users/benchmarks', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_artifacts(self, artifact_id : Annotated[Optional[Any], Field(description="Optional. Filter by artifact Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by artifact status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of artifacts to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created after this date.")] = None, **kwargs) -> ArtifactsResponse:  # noqa: E501
        """Get all artifacts for a user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_artifacts(artifact_id, ticket_id, bid_id, agent_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param artifact_id: Optional. Filter by artifact Id.
        :type artifact_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param status: Optional. Filter by artifact status.
        :type status: object
        :param page_size: Optional. The number of artifacts to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return artifacts created before this date.
        :type before: object
        :param after: Optional. Only return artifacts created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ArtifactsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_artifacts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_artifacts_with_http_info(artifact_id, ticket_id, bid_id, agent_id, status, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_artifacts_with_http_info(self, artifact_id : Annotated[Optional[Any], Field(description="Optional. Filter by artifact Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by artifact status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of artifacts to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return artifacts created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all artifacts for a user.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_artifacts_with_http_info(artifact_id, ticket_id, bid_id, agent_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param artifact_id: Optional. Filter by artifact Id.
        :type artifact_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param status: Optional. Filter by artifact status.
        :type status: object
        :param page_size: Optional. The number of artifacts to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return artifacts created before this date.
        :type before: object
        :param after: Optional. Only return artifacts created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ArtifactsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'artifact_id',
            'ticket_id',
            'bid_id',
            'agent_id',
            'status',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_artifacts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('artifact_id') is not None:  # noqa: E501
            _query_params.append(('artifactId', _params['artifact_id']))

        if _params.get('ticket_id') is not None:  # noqa: E501
            _query_params.append(('ticketId', _params['ticket_id']))

        if _params.get('bid_id') is not None:  # noqa: E501
            _query_params.append(('bidId', _params['bid_id']))

        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "ArtifactsResponse",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users/artifacts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_bids(self, bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of bids to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return bids created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return bids created after this date.")] = None, **kwargs) -> BidsResponse:  # noqa: E501
        """Get all bids for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_bids(bid_id, ticket_id, agent_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of bids to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return bids created before this date.
        :type before: object
        :param after: Optional. Only return bids created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: BidsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_bids_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_bids_with_http_info(bid_id, ticket_id, agent_id, status, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_bids_with_http_info(self, bid_id : Annotated[Optional[Any], Field(description="Optional. Filter by bid Id.")] = None, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of bids to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return bids created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return bids created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all bids for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_bids_with_http_info(bid_id, ticket_id, agent_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param bid_id: Optional. Filter by bid Id.
        :type bid_id: object
        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of bids to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return bids created before this date.
        :type before: object
        :param after: Optional. Only return bids created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(BidsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'bid_id',
            'ticket_id',
            'agent_id',
            'status',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_bids" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('bid_id') is not None:  # noqa: E501
            _query_params.append(('bidId', _params['bid_id']))

        if _params.get('ticket_id') is not None:  # noqa: E501
            _query_params.append(('ticketId', _params['ticket_id']))

        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "BidsResponse",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users/bids', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_user_tickets(self, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of tickets to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return tickets created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return tickets created after this date.")] = None, **kwargs) -> TicketsResponse:  # noqa: E501
        """Get all tickets for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_tickets(ticket_id, agent_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of tickets to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return tickets created before this date.
        :type before: object
        :param after: Optional. Only return tickets created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: TicketsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_tickets_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_tickets_with_http_info(ticket_id, agent_id, status, page_size, page, before, after, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_tickets_with_http_info(self, ticket_id : Annotated[Optional[Any], Field(description="Optional. Filter by ticket Id.")] = None, agent_id : Annotated[Optional[Any], Field(description="Optional. Filter by agent Id.")] = None, status : Annotated[Optional[Any], Field(description="Optional. Filter by ticket status.")] = None, page_size : Annotated[Optional[Any], Field(description="Optional. The number of tickets to return per page. Defaults to 10.")] = None, page : Annotated[Optional[Any], Field(description="Optional. The page number to return. Defaults to 1.")] = None, before : Annotated[Optional[Any], Field(description="Optional. Only return tickets created before this date.")] = None, after : Annotated[Optional[Any], Field(description="Optional. Only return tickets created after this date.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get all tickets for a user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_user_tickets_with_http_info(ticket_id, agent_id, status, page_size, page, before, after, async_req=True)
        >>> result = thread.get()

        :param ticket_id: Optional. Filter by ticket Id.
        :type ticket_id: object
        :param agent_id: Optional. Filter by agent Id.
        :type agent_id: object
        :param status: Optional. Filter by ticket status.
        :type status: object
        :param page_size: Optional. The number of tickets to return per page. Defaults to 10.
        :type page_size: object
        :param page: Optional. The page number to return. Defaults to 1.
        :type page: object
        :param before: Optional. Only return tickets created before this date.
        :type before: object
        :param after: Optional. Only return tickets created after this date.
        :type after: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(TicketsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'ticket_id',
            'agent_id',
            'status',
            'page_size',
            'page',
            'before',
            'after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_tickets" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('ticket_id') is not None:  # noqa: E501
            _query_params.append(('ticketId', _params['ticket_id']))

        if _params.get('agent_id') is not None:  # noqa: E501
            _query_params.append(('agentId', _params['agent_id']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "TicketsResponse",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users/tickets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def manage_user_artifact(self, manage_user_artifact_request : Annotated[ManageUserArtifactRequest, Field(..., description="Artifact to update")], **kwargs) -> Artifact:  # noqa: E501
        """Manage an artifact. Accept or close.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manage_user_artifact(manage_user_artifact_request, async_req=True)
        >>> result = thread.get()

        :param manage_user_artifact_request: Artifact to update (required)
        :type manage_user_artifact_request: ManageUserArtifactRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Artifact
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the manage_user_artifact_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.manage_user_artifact_with_http_info(manage_user_artifact_request, **kwargs)  # noqa: E501

    @validate_arguments
    def manage_user_artifact_with_http_info(self, manage_user_artifact_request : Annotated[ManageUserArtifactRequest, Field(..., description="Artifact to update")], **kwargs) -> ApiResponse:  # noqa: E501
        """Manage an artifact. Accept or close.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manage_user_artifact_with_http_info(manage_user_artifact_request, async_req=True)
        >>> result = thread.get()

        :param manage_user_artifact_request: Artifact to update (required)
        :type manage_user_artifact_request: ManageUserArtifactRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Artifact, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'manage_user_artifact_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method manage_user_artifact" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['manage_user_artifact_request'] is not None:
            _body_params = _params['manage_user_artifact_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "Artifact",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users/artifacts', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def manage_user_bid(self, manage_user_bid_request : Annotated[ManageUserBidRequest, Field(..., description="Bid to update")], **kwargs) -> Bid:  # noqa: E501
        """Accept a bid and grant access to code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manage_user_bid(manage_user_bid_request, async_req=True)
        >>> result = thread.get()

        :param manage_user_bid_request: Bid to update (required)
        :type manage_user_bid_request: ManageUserBidRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Bid
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the manage_user_bid_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.manage_user_bid_with_http_info(manage_user_bid_request, **kwargs)  # noqa: E501

    @validate_arguments
    def manage_user_bid_with_http_info(self, manage_user_bid_request : Annotated[ManageUserBidRequest, Field(..., description="Bid to update")], **kwargs) -> ApiResponse:  # noqa: E501
        """Accept a bid and grant access to code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.manage_user_bid_with_http_info(manage_user_bid_request, async_req=True)
        >>> result = thread.get()

        :param manage_user_bid_request: Bid to update (required)
        :type manage_user_bid_request: ManageUserBidRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Bid, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'manage_user_bid_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method manage_user_bid" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['manage_user_bid_request'] is not None:
            _body_params = _params['manage_user_bid_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "Bid",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users/bids', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_agent(self, update_agent_request : Annotated[UpdateAgentRequest, Field(..., description="User to update")], **kwargs) -> Agent:  # noqa: E501
        """Update agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_agent(update_agent_request, async_req=True)
        >>> result = thread.get()

        :param update_agent_request: User to update (required)
        :type update_agent_request: UpdateAgentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Agent
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_agent_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_agent_with_http_info(update_agent_request, **kwargs)  # noqa: E501

    @validate_arguments
    def update_agent_with_http_info(self, update_agent_request : Annotated[UpdateAgentRequest, Field(..., description="User to update")], **kwargs) -> ApiResponse:  # noqa: E501
        """Update agent  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_agent_with_http_info(update_agent_request, async_req=True)
        >>> result = thread.get()

        :param update_agent_request: User to update (required)
        :type update_agent_request: UpdateAgentRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Agent, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'update_agent_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_agent" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_agent_request'] is not None:
            _body_params = _params['update_agent_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "Agent",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/agents', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_repository(self, update_repository_request : Annotated[UpdateRepositoryRequest, Field(..., description="Repository to update")], **kwargs) -> Repository:  # noqa: E501
        """Update repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_repository(update_repository_request, async_req=True)
        >>> result = thread.get()

        :param update_repository_request: Repository to update (required)
        :type update_repository_request: UpdateRepositoryRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Repository
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_repository_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_repository_with_http_info(update_repository_request, **kwargs)  # noqa: E501

    @validate_arguments
    def update_repository_with_http_info(self, update_repository_request : Annotated[UpdateRepositoryRequest, Field(..., description="Repository to update")], **kwargs) -> ApiResponse:  # noqa: E501
        """Update repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_repository_with_http_info(update_repository_request, async_req=True)
        >>> result = thread.get()

        :param update_repository_request: Repository to update (required)
        :type update_repository_request: UpdateRepositoryRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Repository, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'update_repository_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_repository" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_repository_request'] is not None:
            _body_params = _params['update_repository_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "Repository",
        }

        return self.api_client.call_api(
            '/repositories', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_user(self, update_user_request : Annotated[UpdateUserRequest, Field(..., description="Password to update")], **kwargs) -> User:  # noqa: E501
        """Update user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_user(update_user_request, async_req=True)
        >>> result = thread.get()

        :param update_user_request: Password to update (required)
        :type update_user_request: UpdateUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: User
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_user_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_user_with_http_info(update_user_request, **kwargs)  # noqa: E501

    @validate_arguments
    def update_user_with_http_info(self, update_user_request : Annotated[UpdateUserRequest, Field(..., description="Password to update")], **kwargs) -> ApiResponse:  # noqa: E501
        """Update user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_user_with_http_info(update_user_request, async_req=True)
        >>> result = thread.get()

        :param update_user_request: Password to update (required)
        :type update_user_request: UpdateUserRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(User, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'update_user_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_user_request'] is not None:
            _body_params = _params['update_user_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "User",
            '401': "ErrorsResponse",
        }

        return self.api_client.call_api(
            '/users', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
